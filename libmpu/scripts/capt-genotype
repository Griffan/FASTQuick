#!/usr/bin/perl -w

use strict;
use Getopt::Long;
use Pod::Usage;
use Cwd;
use FindBin;
use lib "$FindBin::Bin";

my $man = 0;
my $help = 0;
my $ped = "";
my $ref = "/data/local/ref/karma.ref/human.g1k.v37.fa";
my $out = "";
my $invcf = "";
my $colmpu = "MPU";
my $colcon = "";
my $colpair = "";
my $chunkmb = 20;
my $run = -1;
my $restart = "";
my $chrom = "";
my $thresContam = 0;
my $defaultContam = 0;
my $scaleContam = 1;
my $offsetContam = 0;
my $mosixNodes = "";
my $ignoreFilter = "";
my $printMono = "";
my $tmpdir = "";

## Parse options and print usage if there is a syntax error,
## or if usage was explicitly requested.
GetOptions("help|?" => \$help, 
	   "man" => \$man,
	   "invcf=s",\$invcf,
	   "ped=s",\$ped,
	   "out=s",\$out,
	   "ref=s",\$ref,
	   "col-mpu=s",\$colmpu,
	   "col-con=s",\$colcon,
	   "thres-con=f",\$thresContam,
	   "default-con=f",\$defaultContam,
	   "scale-con=f",\$scaleContam,
	   "offset-con=f",\$offsetContam,
	   "col-pair=s",\$colpair,
	   "chunk-mb=f",\$chunkmb,
	   "mosix-nodes=s",\$mosixNodes,
	   "chr=s",\$chrom,
	   "run=i",\$run,
	   "restart",\$restart,
	   "ignore-filter",\$ignoreFilter,
	   "print-mono",\$printMono,
	   "tmpdir=s",\$tmpdir,
    ) || pod2usage(2);

pod2usage(1) if $help;

pod2usage(-verbose => 2) if $man;

my $bindir = "$FindBin::Bin";

unless ( ( $invcf ) && ( $ped ) && ( $out ) ) {
    print STDERR "ERROR: Missing required option\n";
    pod2usage(2);
}

die "Cannot open $invcf for reading\n" unless ( -s $invcf );

my %hChrSizes = ();
open(IN,"$ref.fai") || die "Cannot open $ref.fai file for reading";
while(<IN>) {
    my ($chr,$len) = split;
    $hChrSizes{$chr} = $len;
}
close IN;

$out =~ s/.vcf$//;
$out =~ s/.vcf.gz$//;

my @chrs = ($chrom) ? ($chrom) : (1..22,"X","Y");
my @regs = ();
my @mfxs = ();
my @vcfs = ();
foreach my $chr (@chrs) {
    for(my $i=1; $i <= $hChrSizes{$chr}; $i += $chunkmb*1000000) {
	my $end = ($i+$chunkmb*1000000-1);
	$end = $hChrSizes{$chr} if ( $end > $hChrSizes{$chr} );
	my $reg = "$chr:$i-$end";
	my $mfx = "$chr.$i.$end";
	push(@regs,$reg);
	push(@mfxs,$mfx);
	push(@vcfs,"$out.$mfx.vcf.gz");
    }
}

## Read PED file
my @peds = ();
my @mpus = ();
my $icolmpu = -1;
if ( $tmpdir ) {
    open(PED,"$ped") || die "Cannot open $ped\n";
    while(<PED>) {
	my @F = split;
	if ( $#peds < 0 ) {
	    for(my $i=5; $i < @F; ++$i) {
		$icolmpu = $i if ( $F[$i] eq $colmpu );
	    }
	}
	push(@peds,\@F);
	push(@mpus,$F[$icolmpu]);
    }
    close PED;
    die "Cannot find $colmpu column in $ped" if ( $icolmpu < 0 );
}

open(MAK,">$out.Makefile") || die "Cannot open file\n";
print MAK ".DELETE_ON_ERROR:\n\n";
print MAK "all: $out.vcf.gz.tbi\n\n";
print MAK "$out.vcf.gz.tbi: ".join(".tbi ",@vcfs).".tbi\n";
print MAK "\ttouch $out.empty.txt\n";
print MAK "\t(cat $vcfs[0]";
for(my $i=1; $i < @vcfs; ++$i) {
    print MAK "; tabix -r $out.empty.txt $vcfs[$i]";
}
print MAK ") > $out.vcf.gz\n";
#print MAK "\t(zcat $vcfs[0] | head -100 | grep ^#; zcat @vcfs | grep -v ^#;) | $bindir/bgzip -c > $out.vcf.gz\n";
print MAK "\t$bindir/tabix -pvcf $out.vcf.gz\n";
print MAK "\tzcat $out.vcf.gz | cut -f 1-8 | $bindir/bgzip -c > $out.sites.vcf.gz\n\n";
print MAK "\trm @vcfs ".join(".tbi ",@vcfs).".tbi $out.empty.txt\n";
print MAK "\t$bindir/tabix -pvcf $out.sites.vcf.gz\n\n";
#my @mosNodes = split(/,/,$mosixNodes);
#my $nMosNodes = $#mosNodes+1;
for(my $i=0; $i < @vcfs; ++$i) {
    #my $mosNode = $mosNodes[$i % $nMosNodes] if ( $mosixNodes );
    print MAK "$vcfs[$i].tbi:\n";
    if ( $tmpdir ) {
	## write new PED file
	##&forkExecWait("mkdir --p $tmpdir/$mfxs[$i]");
	#my $cmd = "mkdir --p $tmpdir/$mfxs[$i]";
	#$cmd = "mosbatch -E/tmp -r$mosNode sh -c '$cmd'" if ( $mosixNodes );
	#print MAK "\t$cmd\n";

	open(OUT,">$out.$mfxs[$i].ped");
	open(SH,">$out.$mfxs[$i].sh");
	print SH "mkdir --p $tmpdir/$mfxs[$i]\n";
	for(my $j=0; $j < @peds; ++$j) {
	    if ( $j > 0 ) {
		$peds[$j]->[$icolmpu] = "$tmpdir/$mfxs[$i]/".($peds[$j]->[1]).".mpu.gz";
		#my $cmd = "$bindir/tabix $mpus[$j] $regs[$i] > $tmpdir/$mfxs[$i]/".($peds[$j]->[1]).".mpu";
		my $cmd = "$bindir/tabix $mpus[$j] $regs[$i] | gzip -c > $tmpdir/$mfxs[$i]/".($peds[$j]->[1]).".mpu.gz";
		print SH "$cmd\n";
		#$cmd = "mosbatch -E/tmp -r$mosNode sh -c '$cmd'" if ( $mosixNodes );
		#print MAK "\t$cmd\n";
	    }
	    print OUT join("\t",@{$peds[$j]})."\n";
	}
	close OUT;
	my $cmd = "$bindir/mpuTool genotype --default-contam $defaultContam --invcf $invcf --region $regs[$i] --ped $out.$mfxs[$i].ped --col-mpu $colmpu ".($colpair ? "--col-mixid $colpair " : "").($colcon ? "--col-con $colcon " : "").($thresContam > 0 ? "--thres-contam $thresContam " : "").($defaultContam > 0 ? "--default-contam $defaultContam " : "").($scaleContam != 1 ? "--scale-contam $scaleContam " : "").($offsetContam > 0 ? "--offset-contam $offsetContam " : "").($ignoreFilter ? "--ignoreFilter " : "").($printMono ? "--print-mono " : "")."--out $vcfs[$i]";
	print STDERR "PrintMono!\n" if ( $printMono);
	print SH "$cmd\n";
	#$cmd = "mosbatch -E/tmp -r$mosNode sh -c '$cmd'" if ( $mosixNodes );
	#print MAK "\t$cmd\n";
	#print MAK "\trm -rf $tmpdir/$mfxs[$i]/\n";
	#print MAK "\t$bindir/tabix -pvcf $vcfs[$i]\n\n";
	print SH "rm -rf $tmpdir/$mfxs[$i]/\n";
	print SH "$bindir/tabix -pvcf $vcfs[$i]\n";
	close SH;
	if ( $mosixNodes ) {
	    $cmd = "mosbatch -E/tmp -j$mosixNodes sh $out.$mfxs[$i].sh";
	}
	else {
	    $cmd = "sh $out.$mfxs[$i].sh";
	}
	print MAK "\t$cmd\n\n";
    }
    else {
	my $cmd = "$bindir/mpuTool genotype --default-contam $defaultContam --invcf $invcf --region $regs[$i] --ped $ped --col-mpu $colmpu ".($colpair ? "--col-mixid $colpair " : "").($colcon ? "--col-con $colcon " : "").($thresContam > 0 ? "--thres-contam $thresContam " : "").($defaultContam > 0 ? "--default-contam $defaultContam " : "").($scaleContam != 1 ? "--scale-contam $scaleContam " : "").($offsetContam > 0 ? "--offset-contam $offsetContam " : "").($ignoreFilter ? "--ignoreFilter " : "").($printMono ? "--print-mono " : "")."--out $vcfs[$i]";
	#$cmd = "mosbatch -E/tmp -r$mosNode sh -c '$cmd'" if ( $mosixNodes );
	$cmd = "mosbatch -E/tmp -j$mosixNodes sh -c '$cmd'" if ( $mosixNodes );
	print MAK "\t$cmd\n";
	print MAK "\t$bindir/tabix -pvcf $vcfs[$i]\n\n";
    }
}
close MAK;

print "Finished generating CAPT Makefile\n";
if ( $run < 0 ) {
    print "CAPT will run the with the following commond:\n";
    print "\tmake -f $out.Makefile -j [# of parallel jobs]\n";
    print "Or perform sanity checking using the following command:\n";
    print "\tmake -f $out.Makefile -n\n";
}
elsif ( $run == 0 ) {
    print "Running maximum parallel jobs of CAPT\n";
    my $cmd = "make -f $out.Makefile -j ".(($restart) ? " -B" : "");
    print "$cmd\n";
    print `$cmd`;
}
else {
    print "Running $run parallel jobs of CAPT\n";
    my $cmd = "make -f $out.Makefile -j $run".(($restart) ? " -B" : "");
    print "$cmd\n";
    print `$cmd`;
}

sub forkExecWait {
    my $cmd = shift;
    print "forkExecWait(): $cmd\n";
    my $kidpid;
    if ( !defined($kidpid = fork()) ) {
	die "Cannot fork: $!";
    }
    elsif ( $kidpid == 0 ) {
	exec($cmd);
	die "Cannot exec $cmd: $!";
    }
    else {
	waitpid($kidpid,0);
    }
}

__END__

=head1 NAME

epacts make-kin - Create kinship matrix from VCF file for EPACTS

=head1 SYNOPSIS

epacts make-kin [options] 

 Required Options (Run epacts single -man or see wiki for more info):
   -vcf STR          Input VCF file (tabixed and bgzipped)
   -out STR          Output kinship file name

 Key Options (Run epacts single -man or see wiki for more info):
   -help             Print out brief help message [OFF]
   -man              Print the full documentation in man page style [OFF]
   -ped STR          PED file containing subset of individuals to include []
   -field STR        VCF's FORMAT field of genotypes or dosages [GT]
   -unit INT         Base pair units for a parallel run [10000000]
   -sepchr           Indicator of separated VCF per chromosome [OFF]
   -run INT          Run immediately with specified # CPUs [0]
   -min-maf FLT      Minimum minor allele frequency [0.01]
   -min-callrate FLT Minimum call rate [0.95]
   -remove-complex   Remove complex regions with high LD

 Other Options (Run epacts single -man or see wiki for more info):
   -chr STR         Specific chromosome to run association []
   -pass            use only pass-filtered sites [OFF]
   -info STR        substring in the INFO field to be matched []
   -include-sex-chr Include sex chromosome (not recommended) [OFF]
   -restart         Ignore intermediate results and restart [OFF]
   -nodes STR       Comma-separated list of MOSIX cluster nodes []

=head1 EPACTS WIKI DOCUMENTASTION

 Visit http://genome.sph.umich.edu/wiki/EPACTS for detailed documentation

=head1 OPTIONS

=over 8

=item B<-help>

Print a brief help message and exits.

=item B<-man>

Prints the manual page and exits.

=item B<-vcf> STR (Required)

Input VCF file, which must be tabixed and bgzipped. See B<EPACTS wiki> or http://samtools.sourceforge.net/tabix.shtml for detailed information. When -sepchr option is specified, B<-vcf> argument must point the chr1 file.

=item B<-out> STR (Required)

EPACTS output kinship file name

=item B<-ped> STR

Input PED file containing phenotype and covariate information. It accepts PED file format used in PLINK or MERLIN software. Only second column containing the individual IDs will be important. If omitted, all the individuals in the VCF files will be used for calculating kinship

=item B<-field> STR

VCF's FORMAT field entry to extract the genotype or dosage information. By default, 'GT' is used. If 'PL' or 'GL' field is specified, the genotype likelihoods will be converted into genotype dosages whenever needed. Note that using 'PL' or 'GL' may not create ideal kinship matrix

=item B<-unit> INT

The number of base pairs to be used as a unit of parallelization. Default value is 10,000,000 (10Mb).

=item B<-sepchr> 

Indicator that the VCF files are separated by chromosomes. It assumes that the VCF files are named as [prefix].chr1.[suffix], [prefix].chr2.[suffix], and so on. If B<-sepchr> is specified, B<-vcf> argument must point to the file corresponding to chr1.

=item B<-run> INT

Run EPACTS immediately by invoking 'make' command, with specified number of CPUs. By default, this option is turned off and the user needs to invoke 'make' command by themselves.

=item B<-min-maf> FLT

Minimum minor allele frequency (MAF) threshold to run single variant association test. 

=item B<-min-callrate> FLT

Minimum call rate, which is the proportion of non-missing genotypes, to run single variant association test

=item B<-chr> STR

Run only a specific chromosome

=item B<-pass>

Use only variants with 'PASS' in the FILTER column in the VCF

=item B<-restart>

Ignore intermediate results and restart from the scratch

=item B<-nodes> STR

Comma-separated list of MOSIX cluster nodes. By default, MOSIX will not be used.

=back

=head1 DESCRIPTION

B<epacts> is an efficient and flexible software pipelien for sequence-based
genetic analysis. It takes VCF-formatted file as input and performs a wide
variety of single variant and buden test. 

Visit http://genome.sph.umich.edu/wiki/EPACTS for more detailed documentation

=cut
